#' Run ProDe on pre-processed input data
#'
#' @param prodeInput object of class ProdeInput. This is generated by a first
#'    running \code{getProdeInput} function.
#' @param cores integer, the number of cores, default=1 (no parallelization)
#' @param filterCtrl logical, whether or not to filter genes depending on
#'     mean of control samples, before running RRA algorithm.
#' @param n_iter integer, number of random iterations to generate the background
#'     null distribution of random beta probabilities.
#' @param extendedStats logical, wether to computee extended per-group
#'     stats on score matrix.
#' @export
runProde <- function(prodeInput, cores=1, filterCtrl = T, n_iter=10000, extendedStats=F, computeBack=F){

    start <- Sys.time()
    message("\n\nRunning ProDe on ", nrow(assay(prodeInput)), " genes!\n\n")
    message("[1] Running Linear models fit \t\t\t", Sys.time(), "\n")

    beta_tab <- fitLms( # fast fit linear models to each gene + covariates
        x             = designMatrix(prodeInput),
        y             = SummarizedExperiment::assay(prodeInput),
        extendedStats = extendedStats
    )

    message("[2] Subsetting adj matrix and NodesDegree \t", Sys.time(), "\n")

    # TODO: improve filtering step by including it in an helper function
    # Filtering based on mean of wild-type models
    filtered <-S4Vectors::DataFrame()
    if (filterCtrl){
        keep     <- which(beta_tab[,"ctrl_mean"] < 0)
        filtered <- beta_tab[-keep,]
        beta_tab <- beta_tab[ keep,]
    }
    adj_m    <- filterAdjMatrix(prodeInput, rownames(beta_tab)) # update adj matrix

    # Filtering based on degree == 1 (meaning no connections)
    dds      <- Matrix::rowSums(adj_m)
    if (any(dds == 1)){
        adj_m    <- .filter0DegAdj(adj_m, dds)
        beta_tab <- .filter0DegBet(beta_tab, dds)
    }

    stopifnot(.checkBetAdj(beta_tab, adj_m))

    message("[3] Compute background random distribution \t", Sys.time(), "\n")

    if (computeBack){

        if (cores > 1){

            back_dis <- getRandomBetasPar(
                adj_m  = adj_m,
                n_iter = n_iter,
                cores  = cores
            )

        } else {

            back_dis <- getRandomBetas(
                adj_m  = adj_m,
                n_iter = n_iter
            )

        }

        message("[4] Compute RRA statistics and p-value \t\t", Sys.time(), "\n")

        real_betas <- getRealBetas(
            bet_tab  = beta_tab,
            adj_m    = adj_m,
            back_dis = back_dis
        )

    } else {

        real_betas <- getRealBetasFitDistr(
            bet_tab  = beta_tab,
            adj_m    = adj_m,
            back_par = ww
        )

    }

    ## 4. Collect final output .................................................

    end <- Sys.time()
    message("[5] Done !!! \t\t\t\t\t", end-start)

    out <- S4Vectors::DataFrame(
        "gene" = rownames(beta_tab),
        beta_tab,
        real_betas,
        "node_degree" = c(Matrix::rowSums(adj_m)[rownames(beta_tab)])
    )

    prodeResults(
        out,
        adj_m,
        S4Vectors::DataFrame(filtered)
    )

}

